{
  "hash": "637d6afce1cf62b36bd37d34f5fcae39",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: A simple workflow for async {shiny} with {callr}\nauthor: \"teo\"\ndate: \"2024-01-12\"\nexecute:\n  eval: false\nslug: an-opiniated-workflow-for-async-shiny-with-callr\ncategories: [R, shiny, async programming, callr]\ntags: [shiny module]\nsubtitle: \"\"\nsummary: \"An approach to simplify and standardize async calls in `{shiny}` apps using `{callr}`\"\nauthors: [teo]\nlastmod: \"2024-01-12T00:06:30-06:00\"\nfeatured: yes\nprojects: []\n---\n\n\n\n\n\nIn the `R/Shiny` community we are fortunate to have several approaches for async programming.\nIt is an active field of development with a variety of\noptions depending on the needs of the application. For examples and deeper overviews of\nthe state of async programming in `R`, head over to Veerle van Leemput's\n[writing](https://hypebright.nl/index.php/2023/09/05/mastering-async-programming-shiny/),\nthe [Futureverse documentation](https://www.futureverse.org/) or the\n[mirai](https://github.com/shikokuchuo/mirai/) / [crew](https://github.com/wlandau/crew) repos.\n\nIn this post, I am going to focus on an approach to simplify making multiple\nasync calls in `shiny` applications. Really, it boils down to developing a module\nthat wraps the initialization and polling of a `callr::r_bg` process into a single\nfunction, and makes it easier write a larger async-capable `shiny` app while\nkeeping the code a bit shorter, and more compact.\n\n## The problem\n\nI am working on refactoring a relatively large `shiny` application where many of the\ncomputations are time-consuming. Ideally, I would like to convert the major bottlenecks\ninto async routines. Typically, is is done by setting up `future/promise` constructs or\nsending a job to a subprocess, keeping the main `shiny` process free, and then\npolling the subprocess 'manually' to fetch the result (`callr`/`mirai`/`crew`).\n\nAfter reviewing the available options, and trying a few things, I decided\nto go with `callr` for async, although the `mirai`, and `crew` where close seconds.\nThis choice was mostly because of `callr`'s simplicity and because I have [previous\nexperience](https://discindo.org/post/asynchronous-execution-in-shiny/) with it.\n\nThe `callr` workflow can be sumarised in the following steps:\n\n- send a call to the subprocess (possibly within a reactive and dependent on events within `shiny`)\n- monitor the status of the background process to know when to fetch the results\n- the polling observer has to have a switch, so we don't waste resources on polling\n  while there is nothing running.\n\nIn all, its probably some 15-20 lines of code, depending on the complexity of\nthe function call we are sending to the subprocess. It looks something like this:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# The function we want to run async\n# (sleep is added to mimic long computation)\nhead_six <- function(x, sleep) {\n  Sys.sleep(sleep)\n  head(x)\n}\n\n# the r_bg call\nargs <- list(head_six = head_six, x = my_data, sleep = 5)\nbg_process <- callr::r_bg(\n  func = function(head_six, x, sleep) {\n    head_six(x, sleep)\n  },\n  args = args,\n  supervise = TRUE\n)\n\n# turn on polling after the task has been sent to the subprocess\npoll_switch <- shiny::reactiveVal(TRUE)\n\n# reactive to store the result returned by the subprocess\nresult_rct <- shiny::reactiveVal(NULL)\n\n# monitor the background process\nshiny::observe({\n  shiny::req(isTRUE(poll_switch()))\n  shiny::invalidateLater(300)\n  message(\"checking\")\n\n  alive <- bg_job()$is_alive()\n  if (isFALSE(alive)) {\n    res_rct(bg_job()$get_result())\n    message(\"done\")\n    poll_rct(FALSE)\n  }\n})\n\n# do stuff with `result_rct()`\n```\n:::\n\n\n\n\n\nHaving to write this in 20 different places where async might be needed in\nan application is definitelly a chore, not to mention error-prone as one needs\nto keep track of the names of the process objects, polling switches, and result\nreactives. Then of course, some async bits would need to respond to events, like\nbutton clicks or other reactives in the `shiny` session, while others would need\nto run without explicit triggers, adding to the complexity and maintanence of the\ncodebase.\n\n## The solution\n\nI wanted to simplify the above process and make it quicker to write the async\ncode. I wanted a function or a module server that would take a function by name\nand its arguments and then run the function in a background process, poll the\nprocess and return the result when ready. Additionally, I wanted this module\nto be flexible enough such that one can trigger the execution from the outside\n(e.g., from the parent module) or to run without external triggers.\n\nIn the end, I came up with a solution with 3 components: the function that does the\nlong computation, an _async_ version of this function, and a module server that\nwill do the `shiny` things. Bellow are the 3 parts starting with the trivial `head_six`\nfunction (same as above):\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# The function we want to run async\n# (sleep is added to mimic long computation)\nhead_six <- function(x, sleep) {\n  Sys.sleep(sleep)\n  head(x)\n}\n```\n:::\n\n\n\n\n\nThe async version of the function is a wrapper that is prepared manually for the\nfunction we need to run async. It is abstracting the `callr::r_bg` call, and\ncan live in a separate script (together with the function it wraps) instead\nof the `shiny` server. There probably are ways to generate this function with\ncode, and I might try that soon, but for now creating this wrapper does not\nbother me much. Having an async function that you can test and debug interactivelly\nmight actually be preferred.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Async version of `head_six`\n# calls `r_bg` and returns the process object\nhead_six_async <- function(x, sleep) {\n  args <- list(head_six = head_six, x = x, sleep = sleep)\n  bg_process <- callr::r_bg(\n    func = function(head_six, x, sleep) {\n      head_six(x, sleep)\n    },\n    args = args,\n    supervise = TRUE\n  )\n  return(bg_process)\n}\n```\n:::\n\n\n\n\n\nThe third part is the function (module server) that calls the async version of\nthe function doing the time-consumig task. The module also has reactives\nto switch polling on/off, and an observer to monitor and fetch the result. It\nreturns a list with two elements, a reactive with the result of the async\njob, and a function that updates the polling reactive (`poll_rct`) that allows\none to initiate the task from the outside. For example if we had a button in\nanother module that should trigger the computation _inside_ this async module.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmod_async_srv <- function(id, fun_async, fun_args, wait_for_event = FALSE) {\n  moduleServer( id, function(input, output, session){\n    res_rct <- shiny::reactiveVal(NULL)\n    poll_rct <- shiny::reactiveVal(TRUE)\n\n    if (isTRUE(wait_for_event)) {\n      poll_rct(FALSE)\n    }\n\n    bg_job <- reactive({\n      req(isTRUE(poll_rct()))\n      do.call(fun_async, fun_args)\n    }) |> bindEvent(poll_rct())\n\n    observe({\n      req(isTRUE(poll_rct()))\n      invalidateLater(250)\n      message(sprintf(\"checking: %s\", id))\n\n      alive <- bg_job()$is_alive()\n      if (isFALSE(alive)) {\n        res_rct(bg_job()$get_result())\n        message(sprintf(\"done: %s\", id))\n        poll_rct(FALSE)\n      }\n    })\n\n    return(list(\n      start_job = function() poll_rct(TRUE),\n      get_result = reactive(res_rct())\n    ))\n\n  })\n}\n```\n:::\n\n\n\n\n\nNote that this _is not_ a typical `shiny` module, in that it does not have\n(and does not strictly need) a UI part. So we don't have to worry\nabout the namespace (`ns <- session$ns`) inside it. We simply want to observe\nand return. One could add a UI component to, perhaps, notify the user about the\nprogress (checking, checking, ... done) of the async job.\n\nWith this module, refactoring to async becomes more streamlined. For example,\nwe could have a scenario like this.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nserver <- function(input, output, session) {\n\n  # async job triggered on event (input$go_async_job1)\n  async_job1 <- mod_async_srv(\n    id = \"job1_srv\",\n    fun_async = \"job1_async\",\n    fun_args = list(x = x, z = z),\n    wait_for_event = TRUE\n  )\n\n  observeEvent(input$go_async_job1, {\n    async_job1$start_job()\n  })\n\n  output$x <- renderPlot({\n    plot_fun(async_job1$get_result())\n  })\n\n  # async job that runs without external intervention\n  async_job2 <- mod_async_srv(\n    id = \"job2_srv\",\n    fun_async = \"job2_async\",\n    fun_args = list(a = a, b = b),\n    wait_for_event = FALSE\n  )\n\n  output$y <- renderPlot({\n    table_fun(async_job2$get_result())\n  })\n}\n```\n:::\n\n\n\n\n\nNote that the two instances of `mod_async_srv` use different async functions\nwith different sets of arguments, and are triggered in different ways. Providing\nsome flexibility, while keeping the server code minimal.\n\nNothing special here, no magic, just some wrappers to make life a bit easier when\nwriting large `shiny` applications with async capabilities.\n\n## Demo\n\nTo test out this approach you can download the following `gist`. In it, I have\ntwo `callr` background async jobs, to show the `head` of `iris` and `mtcars`,\nwith different sleep time. The `iris` job waits for user click, while the\n`mtcars` job runs on its own when the app starts. Neither async job blocks\nthe main `shiny` process, as they are both in the background, so the slider and\nhistogram work throughout.\n\n<script src=\"https://gist.github.com/teofiln/7815c3c5197bb231b2188070593029ec.js\"></script>\n\n## Summary\n\nIn this post I went over an approach to organize `callr` background async jobs using\na module, in order to make the async code faster to write, less error prone and overall cleaner.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}