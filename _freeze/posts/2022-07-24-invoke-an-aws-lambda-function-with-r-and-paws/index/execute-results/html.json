{
  "hash": "c31f74f2d0fc0c7c457ecfa52f36e3b9",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: 'How to invoke an AWS Lambda function with R and paws'\nauthor: Teo\nexecute:\n  eval: false\ndate: '2022-07-24'\nslug: invoke-an-aws-lambda-function-with-r-and-paws\ncategories:\n  - R\ntags:\n  - aws\n  - paws\n  - AWS lambda\n  - .Renviron\nsubtitle: ''\nsummary: ''\nauthors: ['teo']\nlastmod: '2022-07-24T16:42:34-06:00'\nfeatured: no\nprojects: []\n---\n\n\n\n\n\nIn recent weeks, I have been trying to learn more about using the `{paws}` software development kit to\ninteract with Amazon Web Services from `R`. So far, my focus was on the basics of `DynamoDB`. How\nto put one item in the database, and how to migrate reasonably sized table into `DynamoDB`. There are \nmore topics on `DynamoDB` that I would focus on, and I hope to document my experience in future posts.\nBut today, I wanted to switch gears to `AWS Lambda`. Specifically, how to invoke an already deployed \ncloud function from `R`. \n\n## AWS Setup\n\nIn my `R`+`AWS` projects I typically include an `.Renviron` file that stores the \nneeded settings and secrets for authenticating with AWS. These environmental variables\nare passed as config when starting services with `paws`. A minimal `.Renviron` for \nthis purpose might look like so:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nACCESS_KEY_ID = \"MYKEY\"\nSECRET_ACCESS_KEY = \"MYSECRET\"\nPROFILE = \"default\"\nREGION = \"us-east-1\"\n```\n:::\n\n\n\n\n\nThen, within our `R` session, we would get these configurations with the typical:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nSys.getenv(\"REGION\")\nSys.getenv(\"PROFILE\")\n```\n:::\n\n\n\n\n\nAlternatively, if we can't or don't want to store secrets in a file, we could set \nthem directly in the code:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nSys.setenv(REGION = 'us-east-2')\n```\n:::\n\n\n\n\n\n## Starting an AWS `Lambda` service in `R`\n\nNow, with our configuration prerequisites in place, we can establish a local lambda \nservice using `paws::lambda`. \n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlambda_service <- paws::lambda(config = list(\n  credentials = list(\n    creds = list(\n      access_key_id = Sys.getenv(\"ACCESS_KEY_ID\"),\n      secret_access_key = Sys.getenv(\"SECRET_ACCESS_KEY\")\n    ),\n    profile = Sys.getenv(\"PROFILE\")\n  ),\n  region = Sys.getenv(\"REGION\")\n))\n```\n:::\n\n\n\n\n\nWith the service started, we can see the functions available in our AWS cloud, and the\noperations we can perform.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n> all_lambdas <- lambda_service$list_functions()\n> sapply(all_lambdas$Functions, \"[[\" , \"FunctionName\")\n[1] \"diamonds\"     \"parity\"       \"r-lambda-poc\"\n```\n:::\n\n\n\n\n\nCurrently, I have three deployed `Lambda` functions, two of which are examples from \nDavid Neuzerling's excellent work with the [{lambdr}](https://lambdr.mdneuzerling.com/) \n`R` package. For more details on these (diamonds and parity), see David's writing on the topic [here](https://mdneuzerling.com/post/serverless-on-demand-parametrised-r-markdown-reports-with-aws-lambda/),\n[here](https://mdneuzerling.com/post/r-on-aws-lambda-with-containers/), and \n[here](https://lambdr.mdneuzerling.com/articles/lambda-runtime-in-container.html), \nwhich was and still is incredibly helpful for me to get started and keep learning.\n\n## Invoking an `AWS lambda` function with `R` and `{paws}`\n\nAs an example, I am going to use the `parity` lambda, described in detail in \none of the [vignettes](https://lambdr.mdneuzerling.com/articles/lambda-runtime-in-container.html) \nof the `{lambdr}` package. The input (payload) of this lambda function is a named list of the form \n`list(number = 2)`, which in `JSON` becomes:\n\n\n\n\n\n::: {.cell}\n\n```{.json .cell-code}\n# parity lambda input payload\n{\"number\": 2}\n```\n:::\n\n\n\n\n\nThe return is also a one-item named list with `JSON` `{\"parity\": \"odd\"|\"even\"}`. The `R` function\nrun to assess the parity is the following:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nparity <- function(number) {\n  list(parity = if (as.integer(number) %% 2 == 0) \"even\" else \"odd\")\n}\n```\n:::\n\n\n\n\n\nTo invoke this function we need to call the `invoke` operation of our lambda service,\nand supply it with 1) the name of the function (or function `arn`), 2) the type of \ninvocation ('DryRun', 'RequestResponse', or 'Event' see `?paws.compute::lambda_invoke`), \nand 3) the input payload  (in this case `'{ \"number\": \"2\" }'`). We'll also ask for \nthe tail of the execution log so we can get more information regarding the duration, \nmemory usage, and billing information. \n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# invoke the parity lambda\nresponse <- lambda_service$invoke(\n  FunctionName = \"parity\",\n  InvocationType = \"RequestResponse\",\n  Payload = '{ \"number\": \"2\" }',\n  LogType = \"Tail\"\n)\n```\n:::\n\n\n\n\n\nAfter a second or two, we can decode the output payload, we are expecting `parity = \"even\"`:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n> response$Payload |> rawToChar() |> cat()\n{\"parity\":\"even\"}\n```\n:::\n\n\n\n\n\nFor the logs, we should first decode the response string, as it comes `base64` encoded. And then,\nconvert to a human-readable character vector:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n> jsonlite::base64_dec(response$LogResult) |> rawToChar() |> cat()\nSTART RequestId: 7c971dd1-938d-4ae7-ad35-e1ee5b59e6bb Version: $LATEST\nEND RequestId: 7c971dd1-938d-4ae7-ad35-e1ee5b59e6bb\nREPORT RequestId: 7c971dd1-938d-4ae7-ad35-e1ee5b59e6bb\tDuration: 778.92 ms\tBilled Duration: 3002 ms\tMemory Size: 128 MB\tMax Memory Used: 98 MB\tInit Duration: 2222.94 ms\n```\n:::\n\n\n\n\n\n(Using `cat()` here because it handles newlines nicely)\n\n## Using `paws` bulding blocks to build a custom AWS `Lambda` invocation function\n\nFirst, we can wrap the call to `paws::lambda` in a function so we can use it to connect\nto different AWS services. For now, we assume the environmental variables are set, but\nwe would implement checks and error handling in production setting.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\naws_connect <- function(service) {\n  service(config = list(\n    credentials = list(\n      creds = list(\n        access_key_id = Sys.getenv(\"ACCESS_KEY_ID\"),\n        secret_access_key = Sys.getenv(\"SECRET_ACCESS_KEY\")\n      ),\n      profile = Sys.getenv(\"PROFILE\")\n    ),\n    region = Sys.getenv(\"REGION\")\n  ))\n}\n```\n:::\n\n\n\n\n\nWith this function, we can now quickly create a `dynamoDB` and `Lambda` services:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlambda_service <- aws_connect(paws::lambda)\nlambda_service$list_functions()\n# output truncated\n\ndynamodb_service <- aws_connect(paws::dynamodb)\ndynamodb_service$list_tables()\n# output truncated\n```\n:::\n\n\n\n\n\nThen, we go to the next step, to wrap the service start and invocation in one function. The\npayload is a named list, which internally is converted to `JSON` by `jsonlite::toJSON`.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninvoke_lambda <-\n  function(function_name,\n           invocation_type,\n           payload,\n           include_logs = FALSE) {\n    # assumes .Renviron is set up\n    lambda_service <- aws_connect(paws::lambda)\n    \n    response <- lambda_service$invoke(\n      FunctionName = function_name,\n      InvocationType = invocation_type,\n      Payload = jsonlite::toJSON(payload),\n      LogType = ifelse(include_logs, \"Tail\", \"None\")\n    )\n    \n    message(\"\\nLambda response payload: \")\n    response$Payload |> rawToChar() |> cat()\n    \n    if (include_logs) {\n      message(\"\\nLambda logs: \")\n      jsonlite::base64_dec(response$LogResult) |> rawToChar() |> cat()\n    }\n    \n    invisible(response)\n  }\n```\n:::\n\n\n\n\n\nFinally, we run our simple helpful wrapper:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n> invoke_lambda(\n+   function_name = \"parity\",\n+   invocation_type = \"RequestResponse\",\n+   payload = list(number = 5),\n+   include_logs = FALSE\n+ )\n\nLambda response payload: \n{\"parity\":\"odd\"}\n\n> invoke_lambda(\n+   function_name = \"parity\",\n+   invocation_type = \"RequestResponse\",\n+   payload = list(number = 5),\n+   include_logs = TRUE\n+ )\n\nLambda response payload: \n{\"parity\":\"odd\"}\nLambda logs: \nSTART RequestId: b3507d9d-1218-4c1a-8a2a-d27c728b5093 Version: $LATEST\nEND RequestId: b3507d9d-1218-4c1a-8a2a-d27c728b5093\nREPORT RequestId: b3507d9d-1218-4c1a-8a2a-d27c728b5093\tDuration: 134.67 ms\tBilled Duration: 135 ms\tMemory Size: 128 MB\tMax Memory Used: 101 MB\n```\n:::\n\n\n\n\n\n## Summary\n\nThese were some baby steps in accessing AWS `Lambda` services and invoking functions \nfrom `R` using `paws`. There is a lot more to be done with `paws` and `lambda`, \nincluding creating lambda functions, linking them to other AWS services, using them\nin `{shiny}` applications, etc. I hope to cover some of these in future posts.",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}