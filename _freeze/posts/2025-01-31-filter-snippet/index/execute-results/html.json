{
  "hash": "bd4d945e75647bc15d6e8bd7457c4a4e",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: How to dynamically filter any dataset in R with `purrr` and `dplyr`\nauthor: \n  - name: teo\n    url: \"https://discindo.org/authors/teo\"\ndate: '2025-01-31'\ncategories:\n  - R\n  - filter\n  - dynamic\n  - purrr\n  - dplyr\ndescription: \"Demo of an approach I use for dynamic filtering of tables (in Shiny)\"\nexecute:\n  eval: false\nimage: \"images/image.png\"\n---\n\n\n\n[![](https://ko-fi.com/img/githubbutton_sm.svg)](https://ko-fi.com/J3J8133RYV)\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n### Interactive and dynamic filtering\n\nThe `{tidyverse}`, and `{dplyr}` in particular, have made data manipulation in `R` a \nbreeze. In an interactive setting, the pattern:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_data |> \n    dplyr::filter(my_col == my_value) |>\n    ...\n```\n:::\n\n\n\ngives a lot of power and joy to everyone, including beginner programmers. \n\nHowever, we often run into hurdles when trying to translate our \nscript written for interactive analysis into code that can be run \nautomatically. Where we won't know ahead of time what column to filter \non, or what values we should retain. \n\nIn such cases, we often write `if` statements, along the lines of:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nif (x == \"my_col1\") {\n    dplyr::filter(my_col1 == my_val1)\n} else if (x == my_col2) {\n    dplyr::filter(my_col2 == my_val2)\n} ...\n```\n:::\n\n\n\nIts easy to see how such approaches become long-winded, error prone, slow, \nand result in untidy, less extensible and maintainable code. \n\nThis is common, for example if you have a `{plumber}` API and an arbitrary\nuser attempts to filter an arbitrary table in a data base. Or if you have\na `{shiny}` application where the user uploads a table, with columns unknown\nto the code and then select one or more of them to filter on.\n\nI have faced this many times, and have always wanted a solution where I can send \ninstructions for filtering in the form of a named list, and get the filtered table.\nFor this to work, the named list would need specify the column, filtering function, \nand values to retain (min, max, val). Then a function would take each element of the\nlist, filter the dataset based on it, and finally return a table that combines all\nthe filters. Or, more accurately, return the _intersect_ of the filtered datasets.\n\nBelow is a function that solves this problem that I developed recently to add flexible \ndynamic filtering to a `{shiny}` application where the user can upload an arbitrary\ndataset, then select arbitrary filter columns and values and obtain the joint filtered\nresult. \n\nTo find the `iris` flowers with sepal length between 4.9 and 5 and from species _setosa_\nand _versicolor_, we would write the following:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsuppressPackageStartupMessages({\n    library(checkmate)\n    library(dplyr)\n    library(purrr)\n})\nl <- list(\n  list(col = \"Sepal.Length\", fun = \"between\", min = 4.9, max = 5),\n  list(col = \"Species\", fun = \"in\", val = c(\"setosa\", \"versicolor\"))\n)\n.filter(iris, l)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Sepal.Length Sepal.Width Petal.Length Petal.Width    Species\n1           4.9         3.0          1.4         0.2     setosa\n2           5.0         3.6          1.4         0.2     setosa\n3           5.0         3.4          1.5         0.2     setosa\n4           4.9         3.1          1.5         0.1     setosa\n5           5.0         3.0          1.6         0.2     setosa\n6           5.0         3.4          1.6         0.4     setosa\n7           4.9         3.1          1.5         0.2     setosa\n8           5.0         3.2          1.2         0.2     setosa\n9           4.9         3.6          1.4         0.1     setosa\n10          5.0         3.5          1.3         0.3     setosa\n11          5.0         3.5          1.6         0.6     setosa\n12          5.0         3.3          1.4         0.2     setosa\n13          4.9         2.4          3.3         1.0 versicolor\n14          5.0         2.0          3.5         1.0 versicolor\n15          5.0         2.3          3.3         1.0 versicolor\n```\n\n\n:::\n:::\n\n\n\n### How does it work\n\nThe function below has two sections. First we do input validation using `{checkmate}`.\nIn a non-interactive setting, we can't rely on the inputs being always correct, so \nvalidating, and returning meaningful errors is essential. For this job, I prefer \n`checkmate` because it has a nice and consistent interface with many \nbuilt-in checking, asserting, and testing functions, but any other approach, including\nbase `R`'s `stopifnot` or `assertthat` would work.\n\nThe second part is the filtering bit, where we have `purrr::map` cycle over each element\nof the filter list, grab the required filter function and go into one of two paths. If\nthe column is numeric (date, datetime, integer, double), we use `dplyr::between` to \nfilter. If, the column is character (string), factor or logical, we go with `%in%`.\n\nAfter cycling over all elements of the filter list, the output would be a list of \nfiltered datasets. We must now combine these into a single table, i.e. the table that\nwe would get if we applied all these filters in one call, or sequentially. To do this,\nwe use a bit more functional programming magic with `purrr::reduce` with the `intersect`\nfunction from `dplyr`. This final step, reduces the list of data frames to a single table\ncontaining only the rows that are shared between the data frames.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#' Filter a dataset\n#' @param .data the data frame\n#' @param .arglist a list of filter specifications\n#' @examples\n#' d <- iris\n#' l <- list(\n#'   list(col = \"Sepal.Length\", fun = \"between\", min = 4, max = 5),\n#'   list(col = \"Species\", fun = \"in\", val = c(\"setosa\", \"versicolor\"))\n#' )\n#' .filter(d, l)\n#' @import checkmate\n#' @import purrr\n#' @import dplyr\n#' @export\n.filter <- function(.data, .arglist) {\n  checkmate::assert_data_frame(.data)\n  checkmate::assert_list(.arglist, types = \"list\")\n  checkmate::assert_subset(\n    purrr::map_chr(.arglist, purrr::pluck, \"col\"),\n    choices = names(.data)\n  )\n  checkmate::assert_subset(\n    purrr::map_chr(.arglist, purrr::pluck, \"fun\"),\n    choices = c(\"in\", \"between\")\n  )\n\n  purrr::map(.arglist, function(x) {\n    col <- x$col\n    fun <- x$fun\n    if (fun == \"between\") {\n      min <- x$min\n      max <- x$max\n      if (is.null(min) || is.null(max)) {\n        return(.data)\n      }\n      return(\n        dplyr::filter(.data, dplyr::between(\n          !!rlang::sym(col), min, max\n        ))\n      )\n    }\n    if (fun == \"in\") {\n      val <- x$val\n      if (is.null(val)) {\n        return(.data)\n      }\n      return(dplyr::filter(.data, `%in%`(\n        as.character(!!rlang::sym(col)), val\n      )))\n    }\n  }) |> purrr::reduce(dplyr::intersect)\n}\n```\n:::\n\n\n\nTo show another example, filter cars with mpg between 15 and 20 and cyl in 4 or 6\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nl <- list(\n    list(col = \"mpg\", fun = \"between\", min = 15, max = 20),\n    list(col = \"cyl\", fun = \"in\", val = c(4, 6))\n)\n.filter(mtcars, l)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n              mpg cyl  disp  hp drat   wt  qsec vs am gear carb\nValiant      18.1   6 225.0 105 2.76 3.46 20.22  1  0    3    1\nMerc 280     19.2   6 167.6 123 3.92 3.44 18.30  1  0    4    4\nMerc 280C    17.8   6 167.6 123 3.92 3.44 18.90  1  0    4    4\nFerrari Dino 19.7   6 145.0 175 3.62 2.77 15.50  0  1    5    6\n```\n\n\n:::\n:::\n\n\n\nPretty neat. In future posts, I'll show how I use this in `{shiny}` context,\nwhere the construction of the filter list should also be automated.\n\n\n### Summary\nIn this post, we explored a method to dynamically filter datasets in R using \n`purrr` and `dplyr`. We discussed the limitations of traditional filtering \napproaches and introduced a flexible function that accepts a list of filter \nspecifications. This function validates inputs using `checkmate` and applies \nthe filters using `purrr` and `dplyr`. We demonstrated its usage with examples \non the `iris` and `mtcars` datasets. This approach is particularly useful in \ninteractive applications like `shiny`, where users can upload arbitrary datasets \nand apply custom filters dynamically.",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}