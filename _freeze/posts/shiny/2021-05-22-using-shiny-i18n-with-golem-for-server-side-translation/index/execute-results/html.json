{
  "hash": "18628e37c7ba9b409b658f633bf454fe",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Using {shiny.i18n} with {golem} for server-side translation\nauthors: ['teo']\ndate: '2021-05-22'\nslug: using-shiny-i18n-with-golem-for-server-side-translation\ncategories:\n  - Shiny\n  - R\n  - golem\n  - shiny.i18n\n  - internationalizations\ntags:\n  - Metamorfosis Foundation\n  - Hackathon\n---\n\n\n\n\nIn this post we share a useful tidbit we learned while developing the demo for the [`OpenBudgetMKD`](discindo.shinyapps.io/OpenBudgetNMK/) application. \n\nLike with most projects at Discindo, the `OpenBudgetMKD` application is based on `R` and `{shiny}`. It uses the `{bs4Dash}` and `shinyWidgets` for their excellent UI components, is packaged with`{golem}`, and will be available in Macedonian, Albanian, and English. From a programming perspective, the most interesting aspect for us was implementing internationalization using the `{shiny.i18n}` package and integrating this into a `{golem}`ized `{shiny}` application. These tools integrate seamlessly and make creating rather powerful and great looking applications easy. Many thanks to the developers for creating these awesome packages!\n\nThe one small glitch we encountered had to do with dynamically updating the language of choices of `shinyWidgets::radioGroupButtons`. Client-side translation using the usual `{shiny.i18n}` [workflow](https://appsilon.github.io/shiny.i18n/articles/basics.html) was not working, and the proposed [solution](https://github.com/Appsilon/shiny.i18n/issues/54) to translate the choices within an `update` function on the server did not work out of the box in `{golem}` because the `i18n$translator` was not in the `server`'s function scope. Specifically, because the `ui` and `server` of `{golem}`ized `{shiny}` applications exist as separate functions in separate scripts, they [do not share the scope](https://shiny.rstudio.com/articles/scoping.html) (like they would in single-file `{shiny}` applications). Normally, we overcome this by using `global.R` to load objects in the environment that are shared by both `ui` and `server`. But in `{golem}`, there is no `global.R`. So what to do?\n\nFortunately, we are again spoiled by the versatility of `{golem}`. The solution is to pass the `i18n` translator object as `golem.option` when running the app, in `golem::run_app()`. Then we can use `golem::get_golem_options` to access the translator wherever we need it, e.g., at the beginning of both `app_ui` and `app_server` to make the translator available in both functions.\n\nWe include a minimal example of below. See also the [repository](https://github.com/discindo/shiny.golem.i18n).\n\n*****\n\n1. Customize `golem::run_app` to load the translator\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# R/run_app\n\nrun_app <- function(\n  onStart = NULL,\n  options = list(), \n  enableBookmarking = NULL,\n  uiPattern = \"/\",\n  ...\n) {\n  with_golem_options(\n    app = shinyApp(\n      ui = app_ui,\n      server = app_server,\n      onStart = onStart,\n      options = options, \n      enableBookmarking = enableBookmarking, \n      uiPattern = uiPattern\n    ), \n    # Initiate the translator as a golem.option\n    golem_opts = list(translator = shiny.i18n::Translator$new(translation_csvs_path = \"inst/app/www/translations/\"))\n  )\n}\n```\n:::\n\n\n\n\n\n2. Get the translator from golem's options\n\n- UI\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# R/app_ui.R\n\napp_ui <- function(request) {\n  # calling the translator sent as a golem option\n  i18n <- golem::get_golem_options(which = \"translator\")\n  i18n$set_translation_language(\"en\")\n  \n  tagList(# Leave this function for adding external resources\n    golem_add_external_resources(),\n    # Your application UI logic\n    fluidPage(\n      h3(\"{golem} app and {shiny.i18n} internationalization\"),\n      h5(\"(With server-side translation)\"),\n      br(),\n      column(\n        width = 4,\n        # select language\n        radioButtons(\n          inputId = \"lang\",\n          label = \"Select language\",\n          inline = TRUE,\n          choices = i18n$get_languages()\n        ),\n        # UI that we'll translate on the server size\n        uiOutput(\"welcome\")\n      )\n    ))\n}\n```\n:::\n\n\n\n\n\n- Server\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\napp_server <- function( input, output, session ) {\n  \n  # calling the translator sent as a golem option\n  i18n <- golem::get_golem_options(which = \"translator\")\n  i18n$set_translation_language(\"en\")\n  \n  # keep track of language object as a reactive\n  i18n_r <- reactive({\n    i18n\n  })\n  \n  # change language\n  observeEvent(input[[\"lang\"]], {\n    shiny.i18n::update_lang(session, input[[\"lang\"]])\n    i18n_r()$set_translation_language(input[[\"lang\"]])\n  })\n  \n  output[[\"welcome\"]] <- renderUI({\n    \n    bg <- switch(input[[\"lang\"]], \n                 \"en\" = \"white\",\n                 \"es\" = \"yellow\",\n                 \"fr\" = \"steelblue\",\n                 \"de\" = \"lightgrey\")\n    \n    div(style = paste(\"padding: 10px; border-radius: 10px; background:\", bg), h3(i18n$t(\"Welcome\")))\n  }) \n}\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}