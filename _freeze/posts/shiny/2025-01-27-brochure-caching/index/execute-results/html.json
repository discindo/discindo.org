{
  "hash": "5aafbd1cd569709641241db93c82d62c",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Sharing data between pages in a multi-page Brochure Shiny application \nauthor:\n  - name: teo\n    url: \"https://discindo.org/authors/teofil\"\nexecute:\n  eval: false\ndate: '2025-01-27'\ncategories: [R, Shiny, Brochure, Cache, multi-page, multi-session]\ndescription: >\n    A breakdown of some approaches for between-page data sharing\n    in a multi-session `{brochure}` `{shiny}` application \nimage: \"images/logos.jpg\"\n---\n\n\n\n\n[![](https://ko-fi.com/img/githubbutton_sm.svg)](https://ko-fi.com/J3J8133RYV)\n\nDuring 2024 I had an opportunity to work on an R/Shiny project for a large \npharmaceutical company. I was in charge of converting a set of complex Excel\nworkbooks into a `{shiny}` application. The application had tight integration\nwith two databases, one for data retrieval and another for storing user history,\npreferences, and results. One of the requirements was that the application works\nwith web-browser buttons (forward, back) and as we know, that is not a feature\nof `{shiny}` out of the box. \n\nA `{shiny}` application by default is single-page and single-session. Meaning \nwhen we navigate from one to another \"page\" in a typical shiny application,\nsome parts of the UI are hidden and others displayed, giving the impression\nthat we went somewhere else. But in fact all of our application's UI is still\nloaded in the browser, and its only partially shown. This is why, by default,\nnavigating with browser buttons does not work. There is simply no previous page\nto return to when we hit `Back`.\n\nThere are a few ways to enable this behavior for `{shiny}` applications. We can\nuse the [`shiny.router`](https://appsilon.github.io/shiny.router/index.html) or \n[`blaze`](https://github.com/nteetor/blaze) packages to 'simulate' navigation \nby modifying the URL paths. There is also functionality within `{shiny}` it self\nto update and parse the URL query string, so one can devise with server logic to\nmimic page-navigation as shown [here](https://stackoverflow.com/a/71807248). These\nmethods work fine, and I have used some of them before for production applications,\nbut none of them [implement true multi-page applications](https://colinfay.me/brochure-r-package/).\n\nThe [`{brochure}` package](https://github.com/ColinFay/brochure), still \n**\"work in progress, use at your own risk\"**, is the only approach so far \nthat enables true multi-page and multi-session `{shiny}` applications. Meaning,\nthe URL \"myapp/page1\" runs in its own R session and shares no data with the\nURL \"myapp/page2\". Therefore, variables input by the user or calculated on page 1\nhave to be somehow saved so page 2 can access them. The `{brochure}` package \nincludes examples and functionality to do just this through either caching\nor browser cookies, with browser local storage and databases as additional \npossibilities. However, all of it has to be done manually, meaning, you as \nthe developer have to know what variables to store and then retrieve in \nthe server on another page. In a single-page `{shiny}` this is typically not\nsomething we worry about, as inputs from \"tab 1\" are still available in the\nsession, even though we've navigated to \"tab 2\".\n\nBack to my large `{shiny}` project I started with. I decided to use `{brochure}`\nfor the full multi-page experience, and even though the final product was an \nimpressive application, I ran into a major hurdle with sharing data between pages.\nI used a local disk cache to store variables in one page and then retrieve them\nlater on other pages. This method is very simple and effective, but I had to cache\ndozens of variables per page, often not single values, but lists, data frames, and\neven some `R6` objects. Commonly, a single variable might be updated in multiple\nplaces in the server or in different submodules, and in all these cases I had to \nremember to cache the object. This resulted in repetitive and complicated code, which\nI did not anticipate soon enough, so when things became too thick and the project was\nin a very advanced state, I had no choice but to keep going. There was no time and budget\nto go back and refactor the data sharing aspect of the code, to come up with a \nmore streamlined solution.\n\nSo, now, after a few months, I came back to this problem and I think I have a minor \nimprovement. In the next few examples I outline step-by-step how one can simplify,\nor at least reduce repetitiveness of page-level caching in `{brochure}` applications. \n\nIn all code below I use these options and load the following packages. The options\nset the browser and instruct `{shiny}` to run the application externally, as \nbrowser button navigation does not make sense in a viewer pane. Moreover, before\neach example, we clear the local disk cache and re-initialize it. This ensures that\nthe new examples are not pulling values stored in a previous' examples cache.\n\n### Prep code\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\noptions(browser = \"/usr/bin/firefox\")\noptions(launch.browser = TRUE)\n\nlibrary(shiny)\nlibrary(brochure)\nlibrary(cachem)\n\nunlink(\"brochure_cache\", recursive = TRUE)\nbrochure_cache <- cachem::cache_disk(\"brochure_cache\")\n```\n:::\n\n\n\n\n### Variables are not shared among `{brochure}` pages\n\nOne of the features of `{brochure}` is that each page runs in its own session\nand is ignorant of variables, reactives, inputs, etc. from other pages. We can \nshow this easily with this basic example. The variable `some_var` is created in\nthe home page (`/`) and when we try to `renderPrint` it in `page2` we get an error\nthat the object is not found.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbrochureApp(\n  # First page\n  page(\n    href = \"/\",\n    ui = fluidPage(\n      h1(\"This is my first page\")\n    ),\n    server = function(input, output, session) {\n      some_var <- 10\n    }\n  ),\n  # Second page\n  page(\n    href = \"/page2\",\n    ui = fluidPage(\n      h1(\"This is my second page\"),\n      verbatimTextOutput(\"some_var\")\n    ),\n    server = function(input, output, session) {\n      output$some_var <- renderPrint(some_var)\n    }\n  )\n)\n```\n:::\n\n\n\n\n### Sharing variables with caching to disk\n\nAs we said, we have to store `some_var` somewhere outside the session of the page\nwhere it was created so we can retrieve it in the server of another page. The chunk\nbelow does that, in `/` we set the cache value `some_var` and in `page2` we get it,\nand can print it in the UI.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbrochureApp(\n  # First page\n  page(\n    href = \"/\",\n    ui = fluidPage(\n      h1(\"This is my first page\")\n    ),\n    server = function(input, output, session) {\n      some_var <- 10\n      brochure_cache$set(\"some_var\", some_var)\n    }\n  ),\n  # Second page\n  page(\n    href = \"/page2\",\n    ui = fluidPage(\n      h1(\"This is my second page\"),\n      verbatimTextOutput(\"some_var\")\n    ),\n    server = function(input, output, session) {\n      some_var <- brochure_cache$get(\"some_var\")\n      output$some_var <- renderPrint(some_var)\n    }\n  )\n)\n```\n:::\n\n\n\n\nNow, this is all great, except if we have dozens of variables that we \nneed to share between pages. In this case we'd have to individually \ncache each of them or update a list and then re-cache the list every \ntime its updated. Or if we need to cache an input, we'd need an observer \nto monitor that input and cache it on each change, potentially adding\nunnecessary workload to the session. It becomes cumbersome quickly, and the \ncode gets long and potentially complex, for a relatively basic operation. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbrochureApp(\n  # First page\n  page(\n    href = \"/\",\n    ui = fluidPage(\n      h1(\"This is my first page\")\n    ),\n    server = function(input, output, session) {\n      var1 <- 10\n      brochure_cache$set(\"var1\", var1)\n      var2 <- 11\n      brochure_cache$set(\"var2\", var2)\n      var3 <- 12\n      brochure_cache$set(\"var3\", var3)\n      var4 <- 13\n      brochure_cache$set(\"var4\", var4)\n      var5 <- 14\n      brochure_cache$set(\"var5\", var5)\n      var6 <- 15\n      brochure_cache$set(\"var6\", var6)\n    }\n  ),\n  # Second page\n  page(\n    href = \"/page2\",\n    ui = fluidPage(\n      h1(\"This is my second page\"),\n      verbatimTextOutput(\"some_var\")\n    ),\n    server = function(input, output, session) {\n      vars <- sapply(1:6, \\(i) brochure_cache$get(paste0(\"var\", i)))\n      output$some_var <- renderPrint(sum(vars))\n    }\n  )\n)\n```\n:::\n\n\n\n\n### Simplifying the caching of several variables\n\nWhat I was hoping for at the time is for a single-step caching of the state \nof the page session right before the user navigates to another page. It did \nnot occur to me that a mechanism for this was already available in `{shiny}`.\nSimply use `onSessionEnded` to harvest and cache the variables you need to \nshare with another page. So simple.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbrochureApp(\n  # First page\n  page(\n    href = \"/\",\n    ui = fluidPage(\n      h1(\"This is my first page\")\n    ),\n    server = function(input, output, session) {\n      var1 <- 1\n      var2 <- 2\n      var3 <- 3\n      var4 <- 4\n      var5 <- 5\n      var6 <- 6\n\n      onSessionEnded(function(x) {\n        lapply(1:6, \\(i) {\n          brochure_cache$set(paste0(\"var\", i), get(paste0(\"var\", i)))\n        })\n      })\n    }\n  ),\n  # Second page\n  page(\n    href = \"/page2\",\n    ui = fluidPage(\n      h1(\"This is my second page\"),\n      verbatimTextOutput(\"some_var\")\n    ),\n    server = function(input, output, session) {\n      vars <- sapply(1:6, \\(i) brochure_cache$get(paste0(\"var\", i)))\n      output$some_var <- renderPrint(sum(vars))\n    }\n  )\n)\n```\n:::\n\n\n\n\nRegardless of how many times `var1` is updated during the session, we\ndon't have to worry about caching it. It will get done when the session\nis closed, i.e. when the user navigates to another page or closes the \nweb page. \n\n### Cleaner approach. A list to store variables to be cached\n\nThinking about this some more, it certainly makes sense to have a\npage-level list of variables that need to be cached. Then, when we\ncache on session end, we can cycle over the contents of that list,\nnot dozens of individual variables. Along the lines of:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbrochureApp(\n  # First page\n  page(\n    href = \"/\",\n    ui = fluidPage(\n      h1(\"This is my first page\")\n    ),\n    server = function(input, output, session) {\n      var1 <- 1\n      var2 <- 2\n      var3 <- 3\n      var4 <- 4\n      var5 <- 5\n      var6 <- 6\n\n      to_cache_list <- list()\n      to_cache_list$var1 <- var1\n      to_cache_list$var3 <- var3\n      to_cache_list$var5 <- var5\n\n      onSessionEnded(function() {\n        lapply(names(to_cache_list), \\(x) {\n          brochure_cache$set(x, to_cache_list[[x]])\n        })\n      })\n    }\n  ),\n  # Second page\n  page(\n    href = \"/page2\",\n    ui = fluidPage(\n      h1(\"This is my second page\"),\n      verbatimTextOutput(\"some_var\")\n    ),\n    server = function(input, output, session) {\n      var1 <- brochure_cache$get(\"var1\")\n      var3 <- brochure_cache$get(\"var3\")\n      var5 <- brochure_cache$get(\"var5\")\n      output$some_var <- renderPrint(sum(var1, var3, var5))\n    }\n  )\n)\n```\n:::\n\n\n\n\n### Still to cumbersome? Cache the kitchen sink\n\nFinally, we can take this a step further, perhaps unwisely, and store\nthe entire environment. Within `onSessionEnded`, we define a callback\nfunction whose environment is a child of the server's environment. So \nwe can collect the contents of the parent environment, convert to a list\nfor easier handling, and simply cache all of it as `pageX_data`. Then,\nwhen we need to retrieve a value from pageX, we load the cache and\nindex it with the benefit of knowing that the cache's structure is \ngoing to reflect the structure of the pageX environment.  \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbrochureApp(\n  # First page\n  page(\n    href = \"/\",\n    ui = fluidPage(\n      h1(\"This is my first page\"),\n      sliderInput(\"slide\", \"Shared input\", 1, 10, 1)\n    ),\n    server = function(input, output, session) {\n      observe({\n        slide_value <- brochure_cache$get(\"page_1_data\")[[\"input\"]][[\"slide\"]]\n        if (!is.null(slide_value)) {\n          updateSliderInput(\n            inputId = \"slide\",\n            label = \"Shared input\",\n            value = slide_value\n          )\n        }\n      })\n      var1 <- 6\n      var2 <- 5\n      var3 <- 4\n      var4 <- 3\n      var5 <- 2\n      var6 <- 1\n\n      onSessionEnded(function() {\n        env <- environment()\n        page_env <- as.list(parent.env(env))\n        page_env$output <- NULL\n        page_env$session <- NULL\n        brochure_cache$set(\"page_1_data\", page_env)\n      })\n    }\n  ),\n  # Second page\n  page(\n    href = \"/page2\",\n    ui = fluidPage(\n      h1(\"This is my second page\"),\n      h5(\"Sum of some variables\"),\n      verbatimTextOutput(\"some_var\"),\n      h5(\"Input from previous page\"),\n      verbatimTextOutput(\"slide_input\")\n    ),\n    server = function(input, output, session) {\n      var1 <- brochure_cache$get(\"page_1_data\")[[\"var1\"]]\n      var3 <- brochure_cache$get(\"page_1_data\")[[\"var3\"]]\n      var5 <- brochure_cache$get(\"page_1_data\")[[\"var5\"]]\n      output$some_var <- renderPrint(sum(var1, var3, var5))\n      slide <- reactive(brochure_cache$get(\"page_1_data\")[[\"input\"]][[\"slide\"]])\n      output$slide_input <- renderPrint(slide())\n    }\n  )\n)\n```\n:::\n\n\n\n\nThe example above also covers caching the `input` R6 from the `{shiny}` \nsession and removes the `output` and `session` object, although if needed\nthose could be cached as well. Apart from some input value being needed \nin another page, caching the `input` makes sense so we can update the \ninput widget when we return to pageX. Again, as each page is its own session,\nunlike base `{shiny}`, when we return to pageX the input will be re-initialized\nwith the value set in the code, not with the value previously set by the user,\nso updating it is necessary.\n\nThis last approach comes with a caveat. Its almost never a good idea to cache\neverything. The `input` object, for example, is a large R6 object. There could\nbe data frames, lists, model results, etc within the session that have a large\nfootprint and are not used in other pages. This could inflate the size of the \ncache or cause slowdowns when navigating between pages if saving takes a bit.\n\nPersonally, I prefer the approach of a page-level list of objects to be cached. \nIt is more explicit and can be curated to minimize the size of the cache and\npotentially save time.\n\n### Summary\nIn this post, we explored various methods for sharing data between pages in a \nmulti-page `{brochure}` `{shiny}` application. We started with a basic example \ndemonstrating the isolation of sessions in `{brochure}` and the need for caching \nto share data. We then showed how to use `cachem` to store and retrieve variables \nbetween pages. To simplify the process, we introduced the use of `onSessionEnded` \nto cache variables at the end of a session. Finally, we discussed caching the \nentire environment and the potential pitfalls of this approach. These methods \ncan help streamline data sharing in multi-page `{brochure}` applications, reducing \nrepetitive code and improving maintainability.",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}