{
  "hash": "a2e31573d870b39fea90f7a93012ce1e",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Asynchronous background execution in Shiny using callr\"\nauthors: ['teo', 'novica']\ndate: '2020-05-01'\nslug: asynchronous-execution-in-shiny\ntags:\n- background process\n- asynchronous\n- callr\ncategories:\n- R\n- Shiny\n---\n\n\n\n\nWhen designing `Shiny` applications we commonly associate asynchronous execution with multiple concurrent running sessions of an application. In such cases, when one user has requested a longer computation or a database query, the other users have to wait for this task to finish before they can see their plots and tables. This types of problems are elegantly solved with parallelization with [promises](https://rstudio.github.io/promises/articles/overview.html), so `Shiny` apps can scale up to many concurrent users. \n\nHowever, the current implementation of promises in `Shiny` [does not deal](https://github.com/rstudio/promises/issues/23#) with one, sometimes important, use case. This is when the user that requested a particular task by clicking the dreaded long computation button wants to do other things in the app. For example, we might want to see some other plots while waiting for some web scraping function to finish, or we want to download some `PDF` files while a `SQL` transaction is running. \n\nWe recently came up against this problem of down-time-for-all, both for the current user and other concurrent users. We solved it with the [`callr` package](https://cran.r-project.org/web/packages/callr/callr.pdf), specifically, the `callr::r_bg` function that works similar to promises, but executes a process in the background. So we can initiate a background `R` process, send the long running computation there, do what we need to do in the app, and then come back to the result of that computation once it has finished. In fact, Joe Chang [mentioned](https://github.com/rstudio/promises/issues/23#) this approach as a workaround for the single-user blocking in `Shiny`.\n\nTo see this approach in action, visit the [example app](https://novica.shinyapps.io/sync-async-callr/) and to see the code, jump over to [this](https://github.com/discindo/sync-async-callr) github repository. \n\nNext, we'll delve in the implementation, which is quite straightforward. We designed the synchronous, and asynchronous background execution codes in `Shiny` modules. This makes sense because we want to reuse our background code for various tasks (database transactions, other disk read/write operations, ...). All we need to do is change the function being called inside the background process, which can easily become a parameter to the module's server.\n\n### Regular implementation without asynchronous execution\n\nThe expensive computation we are using in the example app is the following function:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlong_job <- function() { \n  Sys.sleep(10)\n  }\n```\n:::\n\n\n\n\nSo the user needs to wait 10 seconds before continuing to change the number of bins on the Faithful eruptions histogram.\n\nThe server function of the regular, sync module has nothing remarkable. We just call `long_job()` to wait 10 seconds before rendering a message that the job has finished.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsync_srv <- function(input, output, session) {\n  long_run <- eventReactive(input$start, {\n    long_job()\n    return(\"Sync job completed\")\n  })\n  \n  output$did_it_work <- renderText({\n    long_run()\n  })\n}\n```\n:::\n\n\n\n\n### Background processes keep the app alive for current _and_ concurrent users\n\nTo send the expensive computation to the background, we ask `callr::r_bg` to run the relevant function for us and to poll its progress (`supervise = TRUE`). If we have any parameters to send to the long-running function, we pass these as a list to the `args` parameter of `r_bg`. There are none in this case because we just ask `R` to sleep. \n\nTo be able to assess and inform the user about the progress, we store the `value` returned by the `r_bg` call (which is an `S4 r_process` object) and return that from the reactive. Next, we check the status of the background `R` process every second using the `is_alive()` method of the `r_process S4`. While `is_alive()` returns `TRUE`, we keep rendering an 'in progress' message. When the process completes, and `is_alive()` changes to `FALSE`, we render a 'job completed' message. \n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbackground_srv <-\n  function(input, output, session) {\n    long_run <- eventReactive(input$start, {\n      x <- callr::r_bg(\n        func = long_job,\n        supervise = TRUE\n      )\n      return(x)\n    })\n    \n    check <- reactive({\n      invalidateLater(millis = 1000, session = session)\n      \n      if (long_run()$is_alive()) {\n        x <- \"Job running in background\"\n      } else {\n        x <- \"Async job in background completed\"\n      }\n      return(x)\n    })\n    \n    # render the background process message to the UI\n    output$did_it_work <- renderText({\n      check()\n    })\n}\n```\n:::\n\n\n\n\nIn practice, for multiple concurrent users, the `r_bg` approach behaves like approaches based on `promises`. Users can keep interacting with the app, while one (or more) users are running the long computation. But unlike `promises/futures`, `r_bg` also lets the user that initiated the long computation keep interacting with the app. \n\nPretty neat! Hats off to Gábor Csárdi and Winston Chang for this awesome package!\n\nTo see the full code, including the modules' UI functions and the Faithful app with our additions, head over to the [Discindo's](https://github.com/discindo/sync-async-callr) github repository. \nWe hope you find this post interesting and useful. Please get in touch with comments, corrections, suggestions, or to say hi.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}