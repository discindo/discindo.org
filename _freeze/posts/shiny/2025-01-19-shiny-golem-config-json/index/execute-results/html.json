{
  "hash": "d105cac879c954a4d45a155a65bff174",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: How to configure your shiny app content from a remote JSON file\nauthor:\n  - name: teo\n    url: \"https://discindo.org/authors/teofil\"\nexecute:\n  eval: false\ndate: '2025-01-19'\ncategories: [R, Shiny, JSON, shiny module, configuration]\ndescription: >\n  A straighforward way to configure the appearence and content of a Shiny \n  application using a (remote) JSON configuration file\nimage: \"images/logos.png\"\n---\n\n\n\n\n[![](https://ko-fi.com/img/githubbutton_sm.svg)](https://ko-fi.com/J3J8133RYV)\n\nA common question when developing a Shiny application goes along the lines of\n\"How can I configure this?\", \"Can it show different data?\", \"What if I have a\nnew client with a new logo and color scheme?\". There are of course many ways\nto approach configuration questions like these. One way is to implement \nserver logic tied to some data about the client that logged in, keeping all the\nconfiguration logic in one codebase and have one deployed instance. Another way\nis to simply copy the code, make modifications to accommodate the differences in \nthe UI and required data and deploy twice. Either approach, and the myriad \nin-between solutions, have their merits and drawbacks (complexity of code, \nmaintainability, scalability, budget, etc.). Below I write about an approach that \nis somewhere in the middle that I used recently to provide flexibility for a \nclient without major refactoring of the code, while maintaining a single code \nrepository. Keeping it relatively simple, in other words.\n\nIn this example, we assume that there are predefined units of code (modules)\nthat process different datasets and display results. The code can accommodate\nseveral different dataset types, but not all users have or need to access\nall types of data. Or in a subscription setting, one could say not all users\nhave the subscription for each unit. \n\nFurthermore, lets assume that \nthere is some substantive data processing that occurrs before the data arrives \nto our Shiny application. For example, an analyst, you are performing \nsome extensive machine learning procedure for different clients, resulting \nin charts and tables that need to be displayed in the Shiny application. The \nend-user of the application, _is not_ analyzing the data, but seeing the final\nresults, perhaps on some schedule.\n\nIn this scenario, it would help if the analyst can just update a cloud storage\nbucket with some results and automatically update the content of the Shiny\napplication. The Shiny code is of course pointed to the cloud storage bucket \n(or database), so on the next session start can display the new data. Then,\neach client would have a separate bucket, and a separate instance of the Shiny\napplication, to allow for flexibility between clients and different datasets \nversions for the same client.\n\n### Config JSON\n\nNothing particularly novel here. We just create a JSON file with a simple structure.\nThe \"meta\" section has general info about the application and the client (logo, homepage, etc.).\nThe \"general\" section contains info on the title of the particular app instance, and \npath to the data object. Depending on the needs this can be a folder (bucket) with several\nfiles, or a single file (like in the simple example here). Finally, we have the \"pages\"\nsection where add information specific to the different pages/tabs the application has.\n\nSome of the configurability comes in here. We can have separate pages for different \ntypes of data or subscription levels and enable/disable pages from this section accordingly.\n\n\n\n\n::: {.cell}\n\n```{.json .cell-code}\n{\n  \"meta\" : {\n    \"name\" : \"Shiny golem config\",\n    \"version\" : \"0.0.1\",\n    \"description\" : \"An example of an app configured by a config file in the cloud\",\n    \"author\" : \"Discindo\",\n    \"email\" : \"hello@discindodata.com\",\n    \"logo\" : \"www/logo.png\",\n    \"favicon\" : \"favicon.ico\",\n    \"theme\" : \"default\",\n    \"language\" : \"en\",\n    \"homepage\" : \"discindo.org\"\n  },\n  \"general\" : {\n    \"title\" : \"Test Title\",\n    \"subtitle\" : \"A little longer subtitle just to show it (disable with `null`)\",\n    \"data_path\" : \"https://raw.githubusercontent.com/discindo/shiny-golem-json-config/refs/heads/main/iris.csv\",\n    \"data_format\" : \"csv\"\n  },\n  \"pages\" : {\n   \"home\" : {\n        \"title\" : \"Home\",\n        \"icon\" : \"home\",\n        \"url\" : \"/\",\n        \"template\" : \"inst/html/home.html\",\n        \"ui\" : null,\n        \"server\" : null\n    },\n    \"data\" : {\n        \"title\" : \"Data\",\n        \"icon\" : \"table\",\n        \"url\" : \"/data\",\n        \"template\" : null,\n        \"ui\" : \"mod_data_ui\",\n        \"server\" : \"mod_data_server\"\n    },\n    \"about\" : {\n        \"title\" : \"About\",\n        \"icon\" : \"info\",\n        \"url\" : \"/about\",\n        \"template\" : \"inst/html/about.html\",\n        \"ui\" : null,\n        \"server\" : null\n    }\n  }\n}\n```\n:::\n\n\n\n\nThe config can be placed in the `inst` folder of the R package (if `{golem}`) or\nsome other folder that is in the resource path of the Shiny app. But it can also\nlive in the remote cloud location. Of course the Shiny app should have the required\npermissions to access these files.\n\nIn the example here, to keep things simple, the 'remote-data' folder is a public \nfolder in the GitHub repository for the code used in this post. No additional files\nor variables are needed to access the config JSON and the data files. But if the data\nare in a private bucket at a cloud provider, the app would need to have read permissions\nfor that bucket. Either through AWS IAM credentials, or Google cloud token, etc..\n\n### Shiny code \n\nThe Shiny app will need to load the config JSON from the cloud or local location,\nand use the configurations set by the user to generate the right content. In the example,\nI am using the `{golem}` setup, so there are separate `app_ui.r` and `app_server.r` scripts.\nEach one loads the JSON config using `jsonlite` and accesses the slots in the resulting\nlist for the values it needs. If there are some expensive or repeated steps performed\nin the ui and server functions, we could use golem options or some other mechanism to \nparse the config JSON only once and pass the list as an argument or option to the main\nui and server functions. But it this, admittedly simplified example, we parse the config\ntwice, as its quite small. \n\nIn the `{rhino}` framework, something similar can be achieved by loading the config in\n`app.R`, and then using it in functions from `/logic/`. And in a \"base\" Shiny app, \na straightforward approach would be to parse the config in `global.r` which would make\nthe variable available in the scope of the ui and server functions. \n\n#### UI\n\nIn the ui function we:  \n\n  - load the config, \n  - generate the pages UIs using `nav_panel` from `bslib`,\n  - generate some basic aspects of the UI (brand, title, subtitle),\n  - and finally `splice` in the pages/tabs \n\nTo generate the content of the pages, we use either HTML Templates or Shiny modules. \nOf course this is not necessary, we can use R to write the HTML for the Home and\nAbout pages, or can make modules for all the pages, even if those modules are not\nintended to be reused. In the `{golem}` approach it is convenient that the \nmodule's functions are exported from the package and can be accessed with `getFunction`.\nSimilar approaches would work for `{rhino}` and base shiny setups. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\napp_ui <- function(request) {\n  config <- jsonlite::read_json(\"https://raw.githubusercontent.com/discindo/shiny-golem-json-config/refs/heads/main/remote-data/app-config.json\")\n  pages <- purrr::map(\n    config$pages, function(x) {\n      if (!is.null(x$template)) {\n        return(bslib::nav_panel(\n          title = x$title,\n          shiny::htmlTemplate(x$template)\n        ))\n      } else if (!is.null(x$ui)) {\n        return(bslib::nav_panel(\n          title = x$title,\n          getFunction(x$ui)(id = \"data_1\")\n        ))\n      } else {\n        return(bslib::nav_panel(\n          title = x$title,\n          x$title\n        ))\n      }\n    }\n  )\n  shiny::tagList(\n    # Leave this function for adding external resources\n    golem_add_external_resources(),\n    # Your application UI logic\n    shiny::div(\n      class = \"container\",\n      bslib::page_navbar(\n        theme = bslib::bs_theme(\n          bootswatch = \"litera\",\n          base_font = bslib::font_google(\"Lato\")\n        ),\n        inverse = FALSE,\n        underline = FALSE,\n        title = shiny::a(\n          href = config$meta$homepage,\n          target = \"_blank\",\n          shiny::img(src = config$meta$logo, height = \"70px\")\n        ),\n        header = shiny::div(\n          class = \"p-5 text-center\",\n          shiny::h4(config$general$title),\n          shiny::h6(config$general$subtitle)\n        ),\n        bslib::nav_spacer(),\n        rlang::splice(unname(pages))\n      )\n    )\n  )\n}\n```\n:::\n\n\n\n\n#### Server\n\nIn this example, the server is even simpler. All we need to do here is cycle over \nthe `$pages` slot of the config, find the pages that have a `server` slot, and\ncall the module server (obviously using the same `id` as in the ui). The data\nis passed to the module server as an argument, although this is not strictly \nrequired, as we can use `session$userData` to share the object across modules, \nor use some other mechanism. Again, in this simple example, there is only one\ndata object, and we don't do much with it apart to render a table. But in a \nreal application we might need multiple files and more involved server logic. \nIf many server data objects are needed, it might make sense to pass the paths to \nthese objects to the module's server rather than the data it self.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\napp_server <- function(input, output, session) {\n  # Your application server logic\n  config <- jsonlite::read_json(\"inst/app-config.json\")\n  data <- read.csv(config$general$data_path)\n  purrr::map(config$pages, function(x) {\n    if (!is.null(x$server)) {\n      getFunction(x$server)(id = \"data_1\", data = data)\n    }\n  })\n}\n```\n:::\n\n\n\n\nIn the event that we need multiple modules per page, for example modules for\ntable, chart 1, chart2, we could organize the code in one \"page-level\" module,\nthat calls individual tables, charts, maps modules. This way, we don't have to\nbuild functionality to specify and call multiple modules per page _from_ the \nconfig file. i.e., we could keep the config and top-level code simple, and build\ncomplexity at a lower level.\n\n#### Configurability\n\nThe configurability in this simple example comes from the `$general$data_path` \nentry in the config. We can toggle between `iris` and `mtcars`. What other ways\ncan this config json be used to customize the shiny app:\n\n- have multiple 'data' pages, with different datasets or outputs\n- use different data processing modules\n- use different homepage link, logo, title, subtitle, ... \n- use different input data formats specified through the `$general$data_format`\n(this is not implemented in the example, but one could write `switch` logic to \nread csv, excel, parquet, qs, RDS, etc.)\n- the config can be modified to have `data_path` and `data_format` entries on a\nper page (module) level. For example to load csv data in one page and a map in\nanother.\n\nUsing this approach is very similar in to using `{golem}`'s `golem-config.yml`, \nwith the main difference that the the location of the config JSON can be anywhere.\nLike the `golem-config.yml` we can use the above approach to deploy a staging vs\nproduction app instances (i.e. by pointing them to staging vs production data buckets).\n\nThe data bucket directory structure: \n\n\n\n\n::: {.cell}\n\n```{.shell .cell-code}\nremote-data/\n├── app-config.json\n├── iris.csv\n└── mtcars.csv\n```\n:::\n\n\n\n\nOf course, each data bucket, with its own config and data objects should in this case\ncorrespond to a deployed instance of the application. In the event of multiple clients,\nthis makes sense, but it would obviously backfire after 5-10 clients. Maintaining that\nmany data buckets and instances would be best approached with a database.  \n\n### Summary\n\nIn this post, we explored how to configure a Shiny application using a \nremote JSON file. This approach allows for flexible and dynamic updates \nto the app's content and appearance without major code refactoring. We \ndiscussed the structure of the JSON configuration file, how to load it \nin the Shiny app, and how to use it to generate the UI and server logic \ndynamically. This method can be particularly useful for applications \nthat need to display different data or configurations for different \nclients, enabling easy updates by simply modifying the JSON file in a \ncloud storage location.\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}