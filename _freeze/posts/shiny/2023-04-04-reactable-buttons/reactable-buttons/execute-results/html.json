{
  "hash": "c2fd9aadb7509c335b90c5b00c13d236",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: 'How to use buttons in a Reactable widget for navigation in a Shiny application'\nauthor: teo\ndate: '2023-04-04'\nexecute:\n  eval: false\nslug: reactable-buttons\ncategories:\n  - R\n  - Shiny\ntags:\n  - bslib\n  - reactable\nsubtitle: ''\nsummary: 'A few helpful design patterns for navigation in {shiny} applications using buttons in a {reactable} widget and '\nauthors: [teo]\nlastmod: '2023-04-04T08:14:37-06:00'\nfeatured: no\nprojects: []\n---\n\n\n\n\nHow to render and use buttons in tables is a relatively common task faced by `{shiny}` \ndevelopers. Commonly, buttons in tables are used for getting more details about a\nrow of data, for opening modal panels for user input, for displaying charts, and\nof course, for navigation. There are many ways to achieve each of these tasks and \nmany tools to do it with. We can create an HTML table containing buttons \nfrom scratch (e.g. [here](https://discindo.org/post/icons/)), or we can use table\nwidgets like the ones provided by the `{reactable}`, `{DT}` and many other packages.\nIn this post, we'll introduce a very straightforward way to implement buttons and\nuse them for navigation with the `{reactable}` package. Most of what \nyou'll see below is also documented in or derived from the `reactable` [docs](https://glin.github.io/reactable/articles/examples.html#cell-click-actions).\n\n# Putting buttons in a `{reactable}`\n\nTo render buttons inside a [`reactable`](https://glin.github.io/reactable/) widget \nwe need to make an HTML button tag for each row of the table, and add this column \nof buttons as column in the data frame we wish to render. We also need to let `reactable`\nknow that the columns containing our buttons should be interpreted as HTML.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolA <- 1:3\ncolB <- c(\"A\", \"B\", \"C\")\n\nmakeButton <- function(label) {\n  as.character(htmltools::tags$div(htmltools::tags$button(paste(label, \"button\"))))\n}\n\ncolC <- as.character(lapply(c(\"A\", \"B\", \"C\"), makeButton))\n\ndataFrame <- data.frame(A = colA, B = colB, C = colC)\nreactable::reactable(dataFrame,\n                     columns = list(C = reactable::colDef(sortable = FALSE,\n                                                             html = TRUE)))\n```\n:::\n\n\n\n\n# Making the buttons alive\n\nFor the buttons to respond to our clicks, we need to add an `onclick` or `ondbclick` \nevent to each button. To do this, we add the `onclick` argument to the `tags$button`\ntag in our `makeButton` function. Below, we create an event to each button that\nwill show the id of the button clicked:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlabels <- LETTERS[1:3]\n\nbuttonAlert <- function(label) {\n  as.character(htmltools::tags$div(htmltools::tags$button(\n    paste(label, \"button\"),\n    onClick = sprintf(\"alert('Button value is: %s')\", label)\n  )))\n}\n\nalertButtonsHTML <- as.character(lapply(labels, buttonAlert))\n\ntableWithButtons <- reactable::reactable(\n  data.frame(\n    Names = labels,\n    Alert = alertButtonsHTML\n  ),\n  columns = list(\n    Alert = reactable::colDef(sortable = FALSE,\n                              html = TRUE)\n  )\n)\n\ntableWithButtons\n```\n:::\n\n\n\n\nWe also have the option to use `reactable`'s `onClick` argument,\nhowever this requires writing a JavaScript function to figure our which row was\nclicked and then trigger the appropriate action. In some complex scenarios,\nsuch an approach might be necessary, but for this use case, its simple to attach\nan `onclick` event to each button when we create the HTML in R.\n\n# Using the buttons to toggle tabs\n\nSo far, we rendered a `{reactable}` with buttons from R, and added events to the buttons\nsuch that they trigger an alert in the browser showing the button id. This got us\npart of the way towards our goal to use the button clicks for navigation in `{shiny}`\nTo be able to change tabs in a shiny application, we need to send the button id\nfrom the browser to the server. We do this with the `Shiny.setInputValue` JS function\nas described in the shiny docs on [JS to R communication](https://shiny.rstudio.com/articles/communicating-with-js.html).\n\nNext, we'll define two columns of buttons, one that trigger an alert like before,\nand another that sets in input in `{shiny}`'s session that can be accessed from the \nserver. To show this example we need a full `{shiny}` application with a tabset panel\nthat we can toggle by clicking the `{reactable}` buttons. Toggling between tabs\nhappens by the usual `updateTabsetPanel` in an observer listening to the input\nupdated by the buttons.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntab_names <- LETTERS[1:3]\n\nbuttonSetInput <- function(nav_id, nav_value) {\n  as.character(htmltools::tags$div(htmltools::tags$button(\n    paste(\"Go to tab\", nav_value),\n    onClick = sprintf(\n      \"Shiny.setInputValue('%s', '%s', {priority: 'event'})\",\n      nav_id,\n      nav_value\n    )\n  )))\n}\n\nbuttonWithAlert <- function(nav_id, nav_value) {\n  as.character(htmltools::tags$div(htmltools::tags$button(\n    paste(\"Alert\", nav_value),\n    onClick = sprintf(\"alert('Nav id is: %s, and nav value is: %s')\", nav_id, nav_value)\n  )))\n}\n\nalertButtonsHTML <- as.character(lapply(tab_names, buttonWithAlert, nav_id = \"myNav\"))\nsetInputButtonsHTML <- as.character(lapply(tab_names, buttonSetInput, nav_id = \"myNav\"))\n\ntableWithButtons <- reactable::reactable(\n  data.frame(\n    Names = LETTERS[1:3],\n    Alert = alertButtonsHTML,\n    SetInput = setInputButtonsHTML\n  ),\n  columns = list(\n    Alert = reactable::colDef(sortable = FALSE,html = TRUE),\n    SetInput = reactable::colDef(sortable = FALSE, html = TRUE)\n  )\n)\n\nui <- bslib::page_fluid(\n  theme = bslib::bs_theme(version = 5, bootswatch = \"flatly\"),\n  title = \"Reactable buttons navigation\",\n  shiny::titlePanel(\"App navigation with buttons in reactable widget\"),\n  shiny::div(\n    class = \"row\",\n    shiny::div(\n      class = \"col-4\",\n      reactableOutput(\"myTab\"),\n      helpText(\"Input from reactable button is:\"),\n      verbatimTextOutput(\"inputFromTableButton\"),\n      bslib::navs_tab_card(\n        id = \"myTabs\",\n        bslib::nav(title = \"Tab A\", value = \"A\", \"Contents of tab A\"),\n        bslib::nav(title = \"Tab B\", value = \"B\", \"Contents of tab B\"),\n        bslib::nav(title = \"Tab C\", value = \"C\", \"Contents of tab C\")\n      )\n    )\n  )\n)\n\nserver <- function(input, output, session) {\n  output$myTab <- renderReactable({\n    tableWithButtons\n  })\n\n  output$inputFromTableButton <- renderPrint({\n    input$myNav\n  })\n\n  shiny::observeEvent(input$myNav, {\n    shiny::updateTabsetPanel(session = session,\n                             inputId = \"myTabs\",\n                             selected = input$myNav)\n  })\n}\n\nshiny::shinyApp(ui, server)\n```\n:::\n\n\n\n\n# But this is not really navigation\n\nYes, so far we've only toggled tabs on the same page. For this to be 'navigation',\nwhen we click the buttons in the table we should 'jump' from one to another tab. The\nmechanism to do something like this is essentially the same, except we should render\nthe table _within_ one of our tabs, and then have buttons that lead to other tabs. The\nexample app below is a minor tweak of what we saw earlier to achieve exactly that. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntab_names <- LETTERS[1:3]\n\nbuttonSetInput <- function(nav_id, nav_value) {\n  as.character(htmltools::tags$div(htmltools::tags$button(\n    paste(\"Go to tab\", nav_value),\n    onClick = sprintf(\n      \"Shiny.setInputValue('%s', '%s', {priority: 'event'})\",\n      nav_id,\n      nav_value\n    )\n  )))\n}\n\nbuttonWithAlert <- function(nav_id, nav_value) {\n  as.character(htmltools::tags$div(htmltools::tags$button(\n    paste(\"Alert\", nav_value),\n    onClick = sprintf(\"alert('Nav id is: %s, and nav value is: %s')\", nav_id, nav_value)\n  )))\n}\n\nalertButtonsHTML <- as.character(lapply(tab_names, buttonWithAlert, nav_id = \"myNav\"))\nsetInputButtonsHTML <- as.character(lapply(tab_names, buttonSetInput, nav_id = \"myNav\"))\n\ntableWithButtons <- reactable::reactable(\n  data.frame(\n    Names = LETTERS[1:3],\n    Alert = alertButtonsHTML,\n    SetInput = setInputButtonsHTML\n  ),\n  columns = list(\n    Alert = reactable::colDef(sortable = FALSE,html = TRUE),\n    SetInput = reactable::colDef(sortable = FALSE, html = TRUE)\n  )\n)\n\nui <- bslib::page_fluid(\n  theme = bslib::bs_theme(version = 5, bootswatch = \"flatly\"),\n  title = \"Reactable buttons navigation\",\n  shiny::titlePanel(\"App navigation with buttons in reactable widget\"),\n  shiny::div(\n    class = \"row\",\n    shiny::div(\n      class = \"col-4\",\n      helpText(\"Input from reactable button is:\"),\n      verbatimTextOutput(\"inputFromTableButton\"),\n      bslib::navs_tab_card(\n        id = \"myTabs\",\n        bslib::nav(title = \"Tab X\", value = \"X\", reactableOutput(\"myTab\")),\n        bslib::nav(title = \"Tab A\", value = \"A\", \"Contents of tab A\"),\n        bslib::nav(title = \"Tab B\", value = \"B\", \"Contents of tab B\"),\n        bslib::nav(title = \"Tab C\", value = \"C\", \"Contents of tab C\")\n      )\n    )\n  )\n)\n\nserver <- function(input, output, session) {\n  output$myTab <- renderReactable({\n    tableWithButtons\n  })\n  \n  output$inputFromTableButton <- renderPrint({\n    input$myNav\n  })\n  \n  shiny::observeEvent(input$myNav, {\n    shiny::updateTabsetPanel(session = session,\n                             inputId = \"myTabs\",\n                             selected = input$myNav)\n  })\n}\n\nshiny::shinyApp(ui, server)\n```\n:::\n\n\n\n\n# What if we used modules?\n\nIn a realistic app, we would probably use [shiny modules](https://shiny.rstudio.com/articles/modules.html).\nWe could easily construct a scenario where the `reactable` is rendered through a \nmodule, or where each tab is a separate module. The pattern we described above\nworks in this case too, except, with modules, we have keep track of the namespaces.\nModules are isolated, so an input value updated in module X will not be known to \nmodule Y. We have to implement some way of communication between modules.\n\nBelow is one of several ways to send a message from one module to another. In this,\ncase we pass a value from a 'submodule' to the calling module. This is a common\ncase, for example, we have the main app server with top-level navigation, that is\ncalling modules for 'pages' within the application. The key is to return the input\nupdated by the submodule as a reactive that can be observed in the top-level module.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntab_names <- LETTERS[1:3]\n\nbuttonSetInput <- function(nav_id, nav_value) {\n  as.character(htmltools::tags$div(htmltools::tags$button(\n    paste(\"Go to tab\", nav_value),\n    onClick = sprintf(\n      \"Shiny.setInputValue('%s', '%s', {priority: 'event'})\",\n      nav_id,\n      nav_value\n    )\n  )))\n}\n\nbuttonWithAlert <- function(nav_id, nav_value) {\n  as.character(htmltools::tags$div(htmltools::tags$button(\n    paste(\"Alert\", nav_value),\n    onClick = sprintf(\"alert('Nav id is: %s, and nav value is: %s')\", nav_id, nav_value)\n  )))\n}\n\nrTabUI <- function(id) {\n  ns <- NS(id)\n  tagList(\n    reactableOutput(ns(\"myTab\"))\n  )\n}\n\nrTabServer <- function(id) {\n  moduleServer(\n    id,\n    function(input, output, session) {\n      ns <- session$ns\n      \n      alertButtonsHTML <- as.character(lapply(tab_names, buttonWithAlert, nav_id = ns(\"myNav\")))\n      setInputButtonsHTML <- as.character(lapply(tab_names, buttonSetInput, nav_id = ns(\"myNav\")))\n      \n      tableWithButtons <- reactable::reactable(\n        data.frame(\n          Names = LETTERS[1:3],\n          Alert = alertButtonsHTML,\n          SetInput = setInputButtonsHTML\n        ),\n        columns = list(\n          Alert = reactable::colDef(sortable = FALSE,html = TRUE),\n          SetInput = reactable::colDef(sortable = FALSE, html = TRUE)\n        )\n      )\n      \n      output$myTab <- renderReactable({\n        tableWithButtons\n      })\n      \n      return(list(\n        getButtonValue = shiny::reactive(input$myNav)\n      ))\n    }\n  )\n}\n\n\nui <- bslib::page_fluid(\n  theme = bslib::bs_theme(version = 5, bootswatch = \"flatly\"),\n  title = \"Reactable buttons navigation\",\n  shiny::titlePanel(\"App navigation with buttons in reactable widget\"),\n  shiny::div(\n    class = \"row\",\n    shiny::div(\n      class = \"col-4\",\n      helpText(\"Input from reactable button is:\"),\n      verbatimTextOutput(\"inputFromTableButton\"),\n      bslib::navs_tab_card(\n        id = \"myTabs\",\n        bslib::nav(title = \"Tab X\", value = \"X\", rTabUI(\"rtab\") ),\n        bslib::nav(title = \"Tab A\", value = \"A\", \"Contents of tab A\"),\n        bslib::nav(title = \"Tab B\", value = \"B\", \"Contents of tab B\"),\n        bslib::nav(title = \"Tab C\", value = \"C\", \"Contents of tab C\")\n      )\n    )\n  )\n)\n\nserver <- function(input, output, session) {\n  \n  rTabOut <- rTabServer(\"rtab\")\n  \n  output$inputFromTableButton <- renderPrint({\n    rTabOut$getButtonValue()\n  })\n  \n  shiny::observeEvent(rTabOut$getButtonValue(), {\n    shiny::updateTabsetPanel(session = session,\n                             inputId = \"myTabs\",\n                             selected = rTabOut$getButtonValue())\n  })\n}\n\nshiny::shinyApp(ui, server)\n```\n:::\n\n\n\n\nOther ways to implement communication between modules include passing (reactive) \nvalues through `session$userData` (e.g. [here](https://appsilon.com/super-solutions-for-shiny-architecture-1-of-5-using-session-data/))\nor updating values in an environment or `R6` class passed to each module as an \nargument (e.g. [here](https://github.com/ColinFay/golemexamples/tree/master/golemR6)).\n\n# Summary\n\nIn this post we covered some examples of how one could implement navigation between\n'pages' in a `{shiny}` application using buttons in a `reactable`. We saw how to \ngenerate some buttons, how to update input values on button click, how to listen\nto changes from the buttons, and how to pass the user selections between modules.\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}