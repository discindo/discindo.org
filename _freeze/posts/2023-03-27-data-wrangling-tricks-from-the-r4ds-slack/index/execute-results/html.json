{
  "hash": "96fe539ba1057c1403f76165cc8fc175",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Data wrangling tricks from the R4DS slack\nauthor: novica\ndate: '2023-03-27'\nslug: data-wrangling-tricks-from-the-r4ds-slack\nexecute:\n  eval: false\ncategories:\n  - R\ntags:\n  - r4ds\n  - data analysis\n  - shortcuts\nsubtitle: ''\nsummary: ''\nauthors: [novica]\nlastmod: '2023-03-27T18:26:12+02:00'\nfeatured: no\nprojects: []\neditor_options: \n  markdown: \n    wrap: 72\n---\n\n\n\n\n\nEvery now and then there is a question on the [R4DS\nslack](https://www.rfordatasci.com/) that produces a large number of\nreplies. This case was particularly interesting because the user that\nhad the issue deleted all the original content, the question, the\nclarifications and so on.\n\nI thought it would be interesting to document this, because it may be\nuseful to other people.\n\nThe question was posted with regards to some genes data, and the task\nwas to filter out some of the genes that have missing values. But\ngenerally speaking the question can be summarized like this:\n\n*How to filter a dataset in a such way that all observations from a group are\ndropped if the group doesn't meet certain criteria?*\n\nThese are our sample data:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat <- data.frame(\n    groups = c(\"a\", \"a\", \"a\", \"b\", \"b\", \"b\", \"c\", \"c\", \"c\"),\n    features = c(\"c\", \"d\", \"e\", \"e\", \"e\", \"d\", \"d\", \"f\", \"g\"),\n    col1 = c(1, 2, 5, NA, 5, NA, 6, 7, NA),\n    col2 = c(1, 2, 4, 4, NA, 5, 6, NA, 7),\n    col3 = c(1, 3, 4, NA, 5, NA, 4, 7, 8)\n)\n\ndat\n```\n:::\n\n\n\n\n\nWe want to keep only `group a` since it is the only one where none of the\nobservations have missing data.\n\nThere is a case of complete observations in `group c` as well, but it is only\none (on row 7), so we don't want to keep that group.\n\nA simple pipeline to do this would be:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\nlibrary(tidyr)\n\ndat |> \n  drop_na() |> \n  group_by(groups) |> \n  filter(n() == 3)\n```\n:::\n\n\n\n\n\nAfter providing this solution, I thought about the different scenarios where a similar recipe may be needed. For example, what if the data is too big and, `data.table` would be preferred? Or what if the pipeline should be part of a bigger project using `python` for example?\n\n## More R\n\nSo here are the possible solutions with other libraries. First `data.table`.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(data.table)\n\ndat_dt <- setDT(dat)\n\ndat_grp <-\n  dat_dt[complete.cases(dat_dt),][, .N, by = groups][N == 3]\n\ndt_result <- dat_dt[dat_grp, on = \"groups\"]\n\ndt_result\n```\n:::\n\n\n\n\n\nMost of the time I find `data.table` unreadable, and luckily, a `tidytable` solution is also possible.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat |> \n  tidytable::drop_na() |> \n  tidytable::group_by(groups) |> \n  tidytable::filter(dplyr::n() == 3)\n```\n:::\n\n\n\n\n\n## Python\n\nOn to `python`. Here is a simple chain in `pandas` that does the same. \n\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport pandas as pd\n\ndat_py = r.dat\n\n(dat_py.dropna(axis = 0, how = \"any\")\n.groupby(\"groups\")\n.filter(lambda x: len(x) == 3))\n```\n:::\n\n\n\n\n\nThe interesting bit is that `drop_na()` and `dropna()` behave\ndifferently. In\n[tidyr](https://tidyr.tidyverse.org/reference/drop_na.html), the\nfunction assumes that it is checking all of the columns by default,\nwhile in\n[pandas](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.dropna.html)\narguments have to be called to check if any of the columns have missing\nvalues.\n\n## SQL\n\nAnd, how about some `SQL`? It is possible, of course, that your data may be in a database and not in a flat file. Here is a `sqlite` solution.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(DBI)\n\ncon <- dbConnect(RSQLite::SQLite(), \":memory:\")\n\ndbWriteTable(con, \"dat\", dat)\n\nquery <- \"SELECT t1.* FROM dat AS t1\nINNER JOIN (\n    SELECT groups, COUNT(*) as cnt\n    FROM dat\n    WHERE col1 IS NOT NULL AND col2 IS NOT NUll AND col3 IS NOT NULL\n    GROUP BY groups\n) AS t2\nON t1.groups = t2.groups\nWHERE t2.cnt = 3;\"\n  \nres <- dbSendQuery(con, query)\n\ndbFetch(res)\n```\n:::\n\n\n\n\n\n# Summary\n\nThis was a quick post that provides answers with different tools to the question: How to filter a dataset in a such way that all observations from a group are dropped if the group doesn't meet certain criteria?\n\nWe saw how to do it in `tidyverse` and in `data.table`. What is missing is `base R`. Sorry about that! However there are solutions in `pandas` and `SQL`. Hopefully something can be useful to somebody. \n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}