{
  "hash": "a3d15e75d3aa2998d16ffd17b11f6876",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: An R AWS Lambda function to download Tidytuesday datasets\nauthor: 'teo'\ndate: '2023-02-24'\nexecute:\n  eval: false\nslug: an-r-aws-lambda-function-to-download-tidytuesday-datasets\ncategories:\n  - AWS\n  - R\ntags:\n  - r2lambda\n  - AWS Lambda\n  - tidytuesday\nsubtitle: ''\nsummary: 'A detailed walk through the steps to prepare a custom R script for deployment as AWS Lambda with the `r2lambda` package. How to prepare an `R` script? What are the roles of several key arguments? How to request longer timeout or more memory for a Lambda function? How to parse the response payload returned by the Lambda function?'\nauthors: [teo]\nlastmod: '2023-02-24T23:37:01-06:00'\nfeatured: yes\nprojects: ['r2lambda']\nshow_related: true\n---\n\n\n\n\n\n## Use `{r2lambda}` to download Tidytuesday dataset\n\nIn this exercise, we'll create an AWS Lambda function that downloads\nthe [tidytuesday](https://github.com/rfordatascience/tidytuesday/tree/master/data/2023/2023-02-07) \ndata set for the most recent Tuesday (or most recent Tuesday from a date of interest).\n\n## Required packages\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(r2lambda)\nlibrary(jsonlite)\nlibrary(magrittr)\n```\n:::\n\n\n\n\n\n## Runtime function\n\nThe first step is to write the runtime function. This is the function that will be\nexecuted when we invoke the Lambda function after it has been deployed. To download \nthe Tidytuesday data set, we will use the `{tidytuesdayR}` package. In the runtime \nscript, we define a function called `tidytyesday_lambda` that takes one optional \nargument `date`. If `date` is omitted, the function returns the data set(s) for the most \nrecent Tuesday, otherwise, it looks up the most recent Tuesday from a date of interest \nand returns the corresponding data set(s).\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidytuesdayR)\n\ntidytuesday_lambda <- function(date = NULL) {\n  if (is.null(date))\n    date <- Sys.Date()\n  \n  most_recent_tuesday <- tidytuesdayR::last_tuesday(date = date)\n  tt_data <- tidytuesdayR::tt_load(x = most_recent_tuesday)\n  data_names <- names(tt_data)\n  data_list <- lapply(data_names, function(x) tt_data[[x]])\n  return(data_list)\n}\n\ntidytuesday_lambda(\"2022-02-02\")\n```\n:::\n\n\n\n\n\n## R script to build the lambda\n\nTo build the lambda image, we need an `R` script that sources any required code,\nloads any needed libraries, defines a runtime function, and ends with a call to \n`lambdr::start_lambda()`. The runtime function does not have to be defined in this \nfile. We could, for example, source another script, or load a package and set a \nloaded function as the runtime function in the subsequent call to `r2lambda::build_lambda`\n(see below). We save this script to a file and record the path:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nr_code <- \"\n  library(tidytuesdayR)\n\n  tidytuesday_lambda <- function(date = NULL) {\n    if (is.null(date))\n      date <- Sys.Date()\n    \n    most_recent_tuesday <- tidytuesdayR::last_tuesday(date = date)\n    tt_data <- tidytuesdayR::tt_load(x = most_recent_tuesday)\n    data_names <- names(tt_data)\n    data_list <- lapply(data_names, function(x) tt_data[[x]])\n    return(data_list)\n  }\n  \n  lambdr::start_lambda()\n\"\n\ntmpfile <- tempfile(pattern = \"ttlambda_\", fileext = \".R\")\nwrite(x = r_code, file = tmpfile)\n```\n:::\n\n\n\n\n\n## Build, test, and deploy the lambda function\n\n### 1. Build\n\n- We set the `runtime_function` argument to the name of the function we wish the \n`docker` container to run when invoked. In this case, this is `tidytuesday_lambda`.\nThis adds a `CMD` instruction to the `Dockerfile`\n\n- We set the `runtime_path` argument to the path we stored the script defining our\nruntime function.\n\n- We set the `dependencies` argument to `c(\"tidytuesdayR\")`because we need to \nhave the `tidytuesdayR` package installed within the `docker` container if we are\nto download the dataset. This steps adds a `RUN` instruction to the `Dockerfile`\nthat calls `install.packages` to install `{tidytuesdayR}` from CRAN.\n\n- Finally, the `tag` argument sets the name of our Lambda function which we'll use \nlater to test and invoke the function. The `tag` argument also becomes the name of \nthe folder that `{r2lambda}` will create to build the image. This folder will have\ntwo files, `Dockerfile` and `runtime.R`. `runtime.R` is our script from `runtime_path`,\nrenamed before it is copied in the `docker` image with a `COPY` instruction.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nruntime_function <- \"tidytuesday_lambda\"\nruntime_path <- tmpfile\ndependencies <- \"tidytuesdayR\"\n\nr2lambda::build_lambda(\n  tag = \"tidytuesday3\",\n  runtime_function = runtime_function,\n  runtime_path = runtime_path,\n  dependencies = dependencies\n)\n```\n:::\n\n\n\n\n\n### 2. Test\n\nTo make sure our Lambda `docker` container works as intended, we start it locally,\nand invoke it to test the response. The response is a list of three elements:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresponse <- r2lambda::test_lambda(tag = \"tidytuesday3\", payload = list(date = Sys.Date()))\n```\n:::\n\n\n\n\n\n- `status`, should be 0 if the test worked,\n- `stdout`, the standard output stream of the invocation, and\n- `stderr`, the standard error stream of the invocation\n\n`stdout` and `stderr` are `raw` vectors that we need to parse, for example:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrawToChar(response$stdout) \n```\n:::\n\n\n\n\n\nIf the `stdout` slot of the response returns the correct output of our function,\nwe are good to deploy to AWS.\n\n### 3. Deploy\n\nThe deployment step is simple, in that all we need to do is specify the name (tag) of \nthe Lambda function we wish to push to AWS ECR. The `deploy_lambda` function also\naccepts `...`, which are named arguments ultimately passed onto \n`paws.compute:::lambda_create_function`. This is the function that calls the Lambda\nAPI. To see all available arguments run `?paws.compute:::lambda_create_function`.\n\nThe most important arguments are probably `Timeout` and `MemorySize`, which set \nthe time our function will be allowed to run and the amount of memory it will have\navailable. In many cases it will make sense to increase the defaults of 3 seconds\nand 128 mb.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nr2lambda::deploy_lambda(tag = \"tidytuesday3\", Timeout = 30)\n```\n:::\n\n\n\n\n\n### 4. Invoke \n\nIf all goes well, our function should now be available on the cloud awaiting requests.\nWe can invoke it from `R` using `invoke_lambda`. The arguments are:\n\n- `function_name` -- the name of the function\n- `invocation_type` -- typically `RequestResponse`\n- `include_log` -- whether to print the logs of the run on the console\n- `payload` -- a named list with arguments sent to the `runtime_function`. In this\ncase, the runtime function, `tidytuesday_lambda` has a single argument `date`, so\nthe corresponding list is `list(date = Sys.Date())`. As our function can be called\nwithout any argument, we can also send an empty list as the payload.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresponse <- r2lambda::invoke_lambda(\n  function_name = \"tidytuesday3\",\n  invocation_type = \"RequestResponse\",\n  payload = list(),\n  include_logs = TRUE\n)\n```\n:::\n\n\n\n\n\nJust like in the local test, the response payload comes as a raw vector that needs to \nbe parsed into a data.frame:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntidytuesday_dataset <- response$Payload %>% \n  rawToChar() %>% \n  jsonlite::fromJSON(simplifyDataFrame = TRUE)\n\ntidytuesday_dataset[[1]][1:5, 1:5]\n```\n:::\n\n\n\n\n\n## Summary\n\nIn this post, we went over some details about:\n\n- how to prepare an `R` script before deploying it as a Lambda function,   \n- what are the roles of several of the key arguments,   \n- how to request longer timeout or more memory for a Lambda function, and    \n- how to parse the response payload returned by the Lambda function\n\nStay tuned for a follow-up post where we set this Lambda function to run on a \nweekly schedule!\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}