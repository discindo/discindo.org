{
  "hash": "57a2ccfbfdf2252ac155ea42e08e4c72",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Set an R-based AWS Lambda function to run on a schedule\nauthor: 'teo'\ndate: '2023-02-26'\nexecute:\n  eval: false\nslug: set-an-r-based-aws-function-to-run-on-a-schedule\ncategories:\n  - AWS\n  - R\ntags:\n  - r2lambda\n  - AWS Lambda\n  - AWS EventBridge\n  - AWS CloudWatch\n  - cron\n  - Tidytuesday\nsubtitle: ''\nsummary: 'A step-by-step tutorial on how to deploy an R-based AWS Lambda function, how to set it to run on a recurring schedule, how to validate that the execution happens on schedule, and how to clean up. All from the R console.'\nauthors: [teo]\nlastmod: '2023-02-26T18:28:28-06:00'\nfeatured: no\nprojects: ['r2lambda']\nshow_related: true\n---\n\n\n\n\n\nA common use of the AWS Lambda service is to set a function to run on a \nrecurring schedule, e.g. to collect logs, move data, or perform some ETL process.\nIn this post, we'll see how we can set up an AWS Lambda function, running `R`, on \na schedule.\n\n## A lambda runtime function\n\nWe start with a simple function that does not require any input and does not return\nanything. If this example lambda is to run on a schedule, we don't want to worry\nabout any input arguments. Also, we want this lambda function to simply have a \nside effect, like printing something to the logs, without returning any data or writing\nto a database. This will help us greatly with the setup, in that we'll be able to deploy \nand schedule the lambda with minimal involvement from other AWS services.\n\nWith this in mind, we have the following function that simply prints the system time.\nPrinting the current time makes sense because we can easily check that the lambda runs\non the correct schedule from the logs.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncurrent_time <- function() {\n  print(paste(\"CURRENT TIME: \", Sys.time()))\n}\n```\n:::\n\n\n\n\n\n## Build, test, and deploy\n\nThen, we follow the procedure described in [Tidy Tuesday dataset Lambda post](/post/an-r-aws-lambda-function-to-download-tidytuesday-datasets/).\nWe write this to a file that we'll use to build the lambda `docker` image:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nr_code <- \"\n  current_time <- function() {\n    print(paste('CURRENT TIME:', Sys.time()))\n  }\n  \n  lambdr::start_lambda()\n\"\n\ntmpfile <- tempfile(pattern = \"current_time_lambda_\", fileext = \".R\")\nwrite(x = r_code, file = tmpfile)\n```\n:::\n\n\n\n\n\nAnd then build the `docker` image. Note that we don't have any dependencies other \nthan base `R`.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nr2lambda::build_lambda(\n  tag = \"current_time\",\n  runtime_function = \"current_time\",\n  runtime_path = tmpfile,\n  dependencies = NULL\n)\n```\n:::\n\n\n\n\n\nWe test the lambda docker container locally, because it makes sense. The console \noutput should include the log messages and the standard output string showing the\ncurrent time.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nr2lambda::test_lambda(tag = \"current_time\", payload = list())\n```\n:::\n\n\n\n\n\nThen, we deploy the lambda to AWS, leaving the lambda environment to its defaults, \nas 3 seconds should be enough to get and print the current time.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nr2lambda::deploy_lambda(tag = \"current_time\")\n```\n:::\n\n\n\n\n\nFinally, to make sure everything went well, we invoke the cloud instance of our \nfunction. Be sure to include the logs, as this particular function does not return \nanything. \n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nr2lambda::invoke_lambda(\n  function_name = \"current_time\",\n  invocation_type = \"RequestResponse\",\n  payload = list(),\n  include_logs = TRUE\n)\n```\n:::\n\n\n\n\n\n## Schedule to run every minute\n\nTo make a lambda function run on a recurring schedule, we need to update an already \ndeployed function. This involves three steps and two AWS services, [Lambda](https://aws.amazon.com/lambda/) \nfor serverless computing and [EventBridge](https://aws.amazon.com/eventbridge/) \nfor serverless event routing:\n\n- creating a schedule event role (EventBridge, `paws::eventbridge`)\n- adding permissions to this role to invoke lambda functions (Lambda, `paws::lambda`)\n- adding our target lambda function to event (EventBridge, `paws::eventbridge`)\n\nDetailed instructions are available in the [AWS documentation](https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-run-lambda-schedule.html).\nThe function `schedule_lambda` abstracts these three steps in one go. To set a Lambda \non a schedule, we need the name of the function we wish to update, and the rate at which\nwe want EventBridge to invoke it. Two expression formats for setting the rate are supported, \n`cron` and `rate`. For example, to schedule a lambda to run every Sunday at midnight, \nwe could use `execution_rate = \"cron(0 0 * * Sun)\"`. Alternatively, to schedule a lambda\nto run every 15 minutes, we might use `execution_rate = \"rate(15 minutes)\"`. The details are\nin this [AWS article](https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-create-rule-schedule.html)\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nr2lambda::schedule_lambda(\n  lambda_function = \"current_time\", \n  execution_rate = \"rate(1 minute)\"\n  )\n```\n:::\n\n\n\n\n\n## Checking the AWS logs\n\nTo see if our function runs every minute, we can take a look at the AWS logs. If the \nfunction was writing to a database, or dropping files in an S3 bucket, we could also check \nthe contents of those resources for the effects of the scheduled lambda function. But as\nour example function only prints the current time, the only way to know that it indeed runs\nevery minute is to check the logs.\n\nTo do this, we'll use `paws` and `r2lambda::aws_connect` to establish an AWS CloudWatchLogs\nservice locally, and fetch the recent logs to look for traces of our lambda function.\n\nIn the first step, we connect to `cloudwatchlogs` and fetch the names of the log groups.\nInspect the `logs` object below to find the name corresponding to the lambda function\nwhose logs we want to fetch.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlogs_service <- r2lambda::aws_connect(service = \"cloudwatchlogs\")\nlogs <- logs_service$describe_log_groups()\n(logGroups <- sapply(logs$logGroups, \"[[\", 1))\n```\n:::\n\n\n\n\n\nThen, we can grab only the data for our scheduled lambda function:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncurrent_time_lambda_logs <- logs_service$filter_log_events(\n  logGroupName = \"/aws/lambda/current_time\")\n```\n:::\n\n\n\n\n\nAnd pull only the message printed by our `R` function wrapped in the lambda:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmessages <- sapply(current_time_lambda_logs$events, \"[[\", \"message\")\ncurrent_time_messages <- messages[grepl(\"CURRENT TIME\", messages)]\ndata.frame(Current_time_lambda = current_time_messages)\n\n#>                         Current_time_lambda\n#> 1 [1] \"CURRENT TIME: 2023-02-26 22:53:55\"\\n\n#> 2 [1] \"CURRENT TIME: 2023-02-26 22:54:41\"\\n\n#> 3 [1] \"CURRENT TIME: 2023-02-26 22:55:41\"\\n\n#> 4 [1] \"CURRENT TIME: 2023-02-26 22:56:41\"\\n\n#> 5 [1] \"CURRENT TIME: 2023-02-26 22:57:41\"\\n\n```\n:::\n\n\n\n\n\nEvidently, the Lambda function printed the system time every one minute, as we \nintended!\n\n## Clean up\n\nWe don't want to let a this lambda fire every minute, even if trivial it still \nuses resources and incurs some cost. So its wise to delete the event schedule \nrule and maybe even the lambda function it self.\n\nTo remove the event rule, we first need to remove associated targets. In the code\nbelow, we connect to EventBridge, lookup the names of all event rules, find the\nrule we wish to remove (in this case the most-recent one with index 1), and then,\nfirst remove its target followed by deleting the rule it self. (I'll probably\nadd a function abstract this procedure in the `{r2lamdba}` package.)\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# connect to the EventBridge service\nevents_service <- r2lambda::aws_connect(\"eventbridge\")\n# find the names of all rules \nschedule_rules <- events_service$list_rules()[[1]] %>% sapply(\"[[\", 1)\n\n# find the targets associated with the rule we want to remove\nrule_to_remove <- schedule_rules[[1]]\n\ntarget_arn_to_remove <- events_service$list_targets_by_rule(Rule = rule_to_remove)$Targets[[1]]$Id\nevents_service$remove_targets(Rule = rule_to_remove, Ids = target_arn_to_remove)\nevents_service$delete_rule(Name = rule_to_remove)\n\nevents_service$list_rules()[[1]] %>% sapply(\"[[\", 1)\n```\n:::\n\n\n\n\n\nFinally, to remove the Lambda, we do something similar. Look up the names of all\ndeployed functions on our account, and then delete the one(s) we'd like to delete.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlambda_service <- r2lambda::aws_connect(\"lambda\")\nlambda_service$list_functions()$Functions %>% sapply(\"[[\",\"FunctionName\")\nlambda_service$delete_function(FunctionName = \"current_time\")\n```\n:::\n\n\n\n\n\n## Summary\n\nIn this post: \n  - we wrote a simple lambda runtime function, \n  - built a docker image locally,\n  - tested the lambda invocation, \n  - deployed it to AWS Lambda, \n  - updated it to run on a schedule,\n  - checked the AWS logs to confirm it executes at the correct times, and \n  - cleaned up our AWS environment. \n\nI hope you found this tutorial useful, and that it will motivate you to try the `{r2lambda}` \npackage. It is available on [GitHub](https://github.com/discindo/r2lambda) and can \nbe installed with `remotes::install_github`. I am looking for feedback on whether or \nnot the workflows from `r2lambda` are working for other people -- not many have \ntried it so far. I am also interested in suggestions on how to \nimprove the interface, what features to add, what additional documentation to include, \nand so on. Try it and share your experience!\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}